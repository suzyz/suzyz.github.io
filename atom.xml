<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Suzy Zhang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://suzyz.github.io/"/>
  <updated>2017-10-16T13:32:08.000Z</updated>
  <id>https://suzyz.github.io/</id>
  
  <author>
    <name>Suzy Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LintCode/Topological Sorting</title>
    <link href="https://suzyz.github.io/2017/10/16/topological-sorting/"/>
    <id>https://suzyz.github.io/2017/10/16/topological-sorting/</id>
    <published>2017-10-16T13:13:36.000Z</published>
    <updated>2017-10-16T13:32:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Summary"><a href="#Problem-Summary" class="headerlink" title="Problem Summary"></a>Problem Summary</h1><p>Given an directed graph, find any topological order for it.</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>Topological sorting is a very classic algorithm. It can be implemented in many ways. I used Kahn’s algorithm.</p><p>For details, check this:<br><a href="https://en.wikipedia.org/wiki/Topological_sorting" target="_blank" rel="external">Topological sorting - Wikipedia</a></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> struct directedgraphnode &#123;</div><div class="line">     int label;</div><div class="line">     vector&lt;directedgraphnode *&gt; neighbors;</div><div class="line">     directedgraphnode(int x) : label(x) &#123;&#125;;</div><div class="line"> &#125;;</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * @param graph: A list of Directed graph node</div><div class="line">     * @return: Any topological order for the given graph.</div><div class="line">     */</div><div class="line">    <span class="built_in">vector</span>&lt;DirectedGraphNode*&gt; topSort(<span class="built_in">vector</span>&lt;DirectedGraphNode*&gt;&amp; graph) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> n = graph.size();</div><div class="line">        <span class="keyword">int</span> nums[n+<span class="number">1</span>],indegree[n+<span class="number">1</span>];</div><div class="line">       </div><div class="line">       <span class="built_in">memset</span>(indegree,<span class="number">0</span>,<span class="keyword">sizeof</span>(indegree));</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">        &#123;</div><div class="line">        nums[i] = graph[i]-&gt;neighbors.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums[i]; ++j)</div><div class="line">        ++indegree[graph[i]-&gt;neighbors[j]-&gt;label];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">bool</span> vis[n+<span class="number">1</span>];</div><div class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</div><div class="line">        <span class="built_in">vector</span>&lt;DirectedGraphNode*&gt; res;</div><div class="line">        <span class="keyword">int</span> k = n;</div><div class="line">        <span class="keyword">while</span> (k)</div><div class="line">        &#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">       &#123;</div><div class="line">       <span class="keyword">int</span> x = graph[i]-&gt;label;</div><div class="line">       <span class="keyword">if</span> (!vis[x] &amp;&amp; indegree[x]==<span class="number">0</span>)</div><div class="line">       &#123;</div><div class="line">       --k;</div><div class="line">       vis[x] = <span class="literal">true</span>;</div><div class="line">       res.push_back(graph[i]);</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums[i]; ++j)</div><div class="line">       &#123;</div><div class="line">       <span class="keyword">int</span> y = graph[i]-&gt;neighbors[j]-&gt;label;</div><div class="line">       <span class="keyword">if</span> (!vis[y])</div><div class="line">       --indegree[y];</div><div class="line">       &#125;</div><div class="line">       &#125;</div><div class="line">&#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">       <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Summary&quot;&gt;&lt;a href=&quot;#Problem-Summary&quot; class=&quot;headerlink&quot; title=&quot;Problem Summary&quot;&gt;&lt;/a&gt;Problem Summary&lt;/h1&gt;&lt;p&gt;Given an directed graph, find any topological order for it.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://suzyz.github.io/categories/Algorithm/"/>
    
    
      <category term="Graph Theory" scheme="https://suzyz.github.io/tags/Graph-Theory/"/>
    
      <category term="LintCode" scheme="https://suzyz.github.io/tags/LintCode/"/>
    
      <category term="Topological Sorting" scheme="https://suzyz.github.io/tags/Topological-Sorting/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces/873B. Balanced Substring</title>
    <link href="https://suzyz.github.io/2017/10/15/balanced-substring/"/>
    <id>https://suzyz.github.io/2017/10/15/balanced-substring/</id>
    <published>2017-10-15T06:50:12.000Z</published>
    <updated>2017-10-15T07:09:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Summary"><a href="#Problem-Summary" class="headerlink" title="Problem Summary"></a>Problem Summary</h1><p>Given a string S consisting only of characters 0 and 1. A substring starts from l to r is called balanced if the number of zeroes equals to the number of ones in this substring. Determine the length of the longest balanced substring of S.</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>Let sum_zero[i] be the number of zeroes in the substring S[1]S[2]…S[i], and sum_one[i] be the number of ones.</p><p>If a substring S[i]S[i+1]…S[j] is balanced, we have this equation:</p><blockquote><p>sum_zero[j] - sum_zero[i-1] = sum_one[j] - sum_one[i-1] &nbsp; (1)</p></blockquote><p>If we let diff[i] = sum_zero[i] - sum_one[i], then (1) is actually:</p><blockquote><p>diff[j] = diff[i-1] &nbsp; (2)</p></blockquote><p>So, to find the longest substring ending at j, we only need to find the minimum i, such that (2) holds. If such i exits, the length of the longest substring ending at j is j-i+1, which can be used to update the answer.</p><p>The space and time complexities are both O(N).</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> n,diff[maxn];</div><div class="line"><span class="keyword">char</span> s[maxn];</div><div class="line"></div><div class="line"><span class="keyword">int</span> min_idx[maxn*<span class="number">2</span> + <span class="number">10</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="keyword">int</span> sum0 = <span class="number">0</span>, sum1 = <span class="number">0</span>;</div><div class="line"><span class="built_in">memset</span>(min_idx,<span class="number">-1</span>,<span class="keyword">sizeof</span>(min_idx));</div><div class="line"></div><div class="line">min_idx[maxn] = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; ++i)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (s[i] == <span class="string">'0'</span>)</div><div class="line">++sum0;</div><div class="line"><span class="keyword">else</span></div><div class="line">++sum1;</div><div class="line"></div><div class="line">diff[i] = sum0 - sum1;</div><div class="line"><span class="keyword">if</span> (min_idx[diff[i] + maxn] == <span class="number">-1</span>)</div><div class="line">min_idx[diff[i] + maxn] = i;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> idx = min_idx[diff[i] + maxn];</div><div class="line"><span class="keyword">if</span> (idx != <span class="number">-1</span>)</div><div class="line">ans = max(ans,i - idx);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Summary&quot;&gt;&lt;a href=&quot;#Problem-Summary&quot; class=&quot;headerlink&quot; title=&quot;Problem Summary&quot;&gt;&lt;/a&gt;Problem Summary&lt;/h1&gt;&lt;p&gt;Given a string S consisting only of characters 0 and 1. A substring starts from l to r is called balanced if the number of zeroes equals to the number of ones in this substring. Determine the length of the longest balanced substring of S.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://suzyz.github.io/categories/Algorithm/"/>
    
    
      <category term="DP" scheme="https://suzyz.github.io/tags/DP/"/>
    
      <category term="Codeforces" scheme="https://suzyz.github.io/tags/Codeforces/"/>
    
      <category term="Implementation" scheme="https://suzyz.github.io/tags/Implementation/"/>
    
  </entry>
  
  <entry>
    <title>LintCode/Binary Tree Serialization</title>
    <link href="https://suzyz.github.io/2017/10/14/binary-tree-serialization/"/>
    <id>https://suzyz.github.io/2017/10/14/binary-tree-serialization/</id>
    <published>2017-10-14T13:10:57.000Z</published>
    <updated>2017-10-14T13:36:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Summary"><a href="#Problem-Summary" class="headerlink" title="Problem Summary"></a>Problem Summary</h1><p>Serialize and deserialize a binary tree, i.e., write the tree to a string and read the string to reconstruct the exact same binary tree.</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>There are many ways to ‘serialize’ the tree that we can choose from, such as:</p><ol><li>The BFS traversal of the tree.</li><li>The preorder and inorder traversal of the tree.</li></ol><p>I chose the frist one.</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition of TreeNode:</div><div class="line"> * class TreeNode &#123;</div><div class="line"> * public:</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left, *right;</div><div class="line"> *     TreeNode(int val) &#123;</div><div class="line"> *         this-&gt;val = val;</div><div class="line"> *         this-&gt;left = this-&gt;right = NULL;</div><div class="line"> *     &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * This method will be invoked first, you should design your own algorithm </div><div class="line">     * to serialize a binary tree which denote by a root node to a string which</div><div class="line">     * can be easily deserialized by your own "deserialize" method later.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode * root)</span> </span>&#123;</div><div class="line">        <span class="built_in">string</span> s;</div><div class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</div><div class="line">        <span class="keyword">if</span> (root)</div><div class="line">            q.push(root);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (!q.empty())</div><div class="line">        &#123;</div><div class="line">            TreeNode *cur = q.front();</div><div class="line">            q.pop();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (cur == <span class="literal">NULL</span>)</div><div class="line">            &#123;</div><div class="line">                s += <span class="string">"#"</span>;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            s += to_string(cur-&gt;val) + <span class="string">","</span>;</div><div class="line">            q.push(cur-&gt;left);</div><div class="line">            q.push(cur-&gt;right);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * This method will be invoked second, the argument data is what exactly</div><div class="line">     * you serialized at method "serialize", that means the data is not given by</div><div class="line">     * system, it's given by your own serialize method. So the format of data is</div><div class="line">     * designed by yourself, and deserialize it here as you serialize it in </div><div class="line">     * "serialize" method.</div><div class="line">     */</div><div class="line">    <span class="function">TreeNode * <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> &amp;data)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (data.length() == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">        TreeNode * root = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (data[i] != <span class="string">','</span>)</div><div class="line">            root-&gt;val = <span class="number">10</span> * root-&gt;val + data[i++] - <span class="string">'0'</span>;</div><div class="line">        ++i;</div><div class="line"></div><div class="line">        <span class="built_in">vector</span>&lt;TreeNode *&gt; pre,now;</div><div class="line">        pre.push_back(root);</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (i &lt; data.length())</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pre.size(); ++j)</div><div class="line">            &#123;</div><div class="line">                TreeNode *cur = pre[j];</div><div class="line"></div><div class="line">                i = get_val(data,i,&amp;cur-&gt;left,now);</div><div class="line">                i = get_val(data,i,&amp;cur-&gt;right,now);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            pre = now;</div><div class="line">            now = <span class="built_in">vector</span>&lt;TreeNode *&gt;();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_val</span><span class="params">(<span class="built_in">string</span> &amp;data,<span class="keyword">int</span> i,TreeNode **p,<span class="built_in">vector</span>&lt;TreeNode *&gt; &amp;now)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (data[i] == <span class="string">'#'</span>)</div><div class="line">        &#123;</div><div class="line">            *p = <span class="literal">NULL</span>;</div><div class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (data[i] != <span class="string">','</span>)</div><div class="line">            tmp = <span class="number">10</span> * tmp + data[i++] - <span class="string">'0'</span>;</div><div class="line">        </div><div class="line">        *p = <span class="keyword">new</span> TreeNode(tmp);</div><div class="line">        now.push_back(*p);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Summary&quot;&gt;&lt;a href=&quot;#Problem-Summary&quot; class=&quot;headerlink&quot; title=&quot;Problem Summary&quot;&gt;&lt;/a&gt;Problem Summary&lt;/h1&gt;&lt;p&gt;Serialize and deserialize a binary tree, i.e., write the tree to a string and read the string to reconstruct the exact same binary tree.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://suzyz.github.io/categories/Algorithm/"/>
    
    
      <category term="LintCode" scheme="https://suzyz.github.io/tags/LintCode/"/>
    
      <category term="Binary tree" scheme="https://suzyz.github.io/tags/Binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>LintCode/Validate Binary Search Tree</title>
    <link href="https://suzyz.github.io/2017/10/14/validate-binary-search-tree/"/>
    <id>https://suzyz.github.io/2017/10/14/validate-binary-search-tree/</id>
    <published>2017-10-14T07:40:46.000Z</published>
    <updated>2017-10-14T08:05:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Summary"><a href="#Problem-Summary" class="headerlink" title="Problem Summary"></a>Problem Summary</h1><p>Given a binary tree, determine if it is a binary search tree.<br><a id="more"></a><br>Assume a BST is defined as follows:</p><ol><li>The left subtree of a node contains only nodes with keys less than the node’s key.</li><li>The right subtree of a node contains only nodes with keys greater than the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li><li>A single node tree is a BST.</li></ol><h1 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h1><p>We can use DFS to check whether the tree is a BST.</p><p>For each node, we use its value to determine the maximum value of its left subtree and the minimum value of its right subtree.</p><h1 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h1><p>Since the BST required in this problem should not contain duplicate values, we can do an inorder traversal, and if the sequence is stictly increasing, the tree is a BST.</p><h1 id="Code-for-Solution-1"><a href="#Code-for-Solution-1" class="headerlink" title="Code for Solution 1"></a>Code for Solution 1</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * @param root: The root of binary tree.</div><div class="line">     * @return: True if the binary tree is BST, or false</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode * root)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> is_valid_bst(root,INT_MIN,INT_MAX);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_valid_bst</span><span class="params">(TreeNode *root,<span class="keyword">int</span> min,<span class="keyword">int</span> max)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span> (root-&gt;val &lt; min || root-&gt;val &gt; max)</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> is_valid_bst(root-&gt;left,min,root-&gt;val<span class="number">-1</span>) &amp;&amp; is_valid_bst(root-&gt;right,root-&gt;val+<span class="number">1</span>,max);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Summary&quot;&gt;&lt;a href=&quot;#Problem-Summary&quot; class=&quot;headerlink&quot; title=&quot;Problem Summary&quot;&gt;&lt;/a&gt;Problem Summary&lt;/h1&gt;&lt;p&gt;Given a binary tree, determine if it is a binary search tree.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://suzyz.github.io/categories/Algorithm/"/>
    
    
      <category term="LintCode" scheme="https://suzyz.github.io/tags/LintCode/"/>
    
      <category term="Binary Search Tree" scheme="https://suzyz.github.io/tags/Binary-Search-Tree/"/>
    
  </entry>
  
  <entry>
    <title>LintCode/Remove Node In Binary Search Tree</title>
    <link href="https://suzyz.github.io/2017/10/13/remove-node-in-binary-search-tree/"/>
    <id>https://suzyz.github.io/2017/10/13/remove-node-in-binary-search-tree/</id>
    <published>2017-10-13T12:48:37.000Z</published>
    <updated>2017-10-13T13:45:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Summary"><a href="#Problem-Summary" class="headerlink" title="Problem Summary"></a>Problem Summary</h1><p>Given a root of Binary Search Tree with unique value for each node. Remove the node with given value V. If there is no such a node with given value in the binary search tree, do nothing. Remember to keep the tree a binary search tree after removal.</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>Let us solve this recursively.</p><p>For current root,</p><ol><li><p>If we have root-&gt;val &lt; V, then V is in the right subtree of root or it does not exist. So we call removeNode(root-&gt;right,V) and return root.</p></li><li><p>Similarly, if root-&gt;val &gt; V, we call removeNode(root-&gt;left,V) and return root.</p></li><li><p>If we have root-&gt;val == V, we need to remove root.<br>&nbsp; &nbsp;(1) If one of root-&gt;left or root-&gt;right is NULL, we should replace root with the other one and return the new root.<br>&nbsp; &nbsp;(2) If neither of root-&gt;left and root-&gt;right are NULL, we need to find the precursor of root in the inorder traversal of the tree, i.e. the maximum number in the left subtree of root, and replace root with it. In the mean time, we also need to keep the tree a BST.</p></li></ol><p>About the implementation of (2):</p><p>At first I wrote a function “get_precursor” for it. It finds the precursor and removes it from the tree. But it requires a little cooperation of the upper-layer function (see line 45, Code 1). Then I realized it is not necessary. So I wrote a function “get_max” which also can get the precursor but does not change the tree. With this I just need to call get_max(root-&gt;left) and then call removeNode(root-&gt;left,precursor) to remove the precursor from the left subtree (see Code 2). The new method is easier to code and makes the code more robust and explicit.</p><h1 id="Code-1"><a href="#Code-1" class="headerlink" title="Code 1"></a>Code 1</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition of TreeNode:</div><div class="line"> * class TreeNode &#123;</div><div class="line"> * public:</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left, *right;</div><div class="line"> *     TreeNode(int val) &#123;</div><div class="line"> *         this-&gt;val = val;</div><div class="line"> *         this-&gt;left = this-&gt;right = NULL;</div><div class="line"> *     &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * @param root: The root of the binary search tree.</div><div class="line">     * @param value: Remove the node with given value.</div><div class="line">     * @return: The root of the binary search tree after removal.</div><div class="line">     */</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_precursor</span><span class="params">(TreeNode *cur,TreeNode *parent)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (cur-&gt;right != <span class="literal">NULL</span>)</div><div class="line"><span class="keyword">return</span> get_precursor(cur-&gt;right,cur);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (parent != <span class="literal">NULL</span>)</div><div class="line">parent-&gt;right = cur-&gt;left;</div><div class="line"></div><div class="line"><span class="keyword">return</span> cur-&gt;val;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="function">TreeNode * <span class="title">removeNode</span><span class="params">(TreeNode * root, <span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (root-&gt;val == value)</div><div class="line">        &#123;</div><div class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> root-&gt;right;</div><div class="line">        <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> root-&gt;left;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> pre = get_precursor(root-&gt;left,<span class="literal">NULL</span>);</div><div class="line">        <span class="keyword">if</span> (pre == root-&gt;left-&gt;val)</div><div class="line">        root-&gt;left = root-&gt;left-&gt;left;</div><div class="line"></div><div class="line">        root-&gt;val = pre;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">        <span class="keyword">if</span> (root-&gt;val &lt; value)</div><div class="line">        root-&gt;right = removeNode(root-&gt;right,value);</div><div class="line">        <span class="keyword">else</span></div><div class="line">        root-&gt;left = removeNode(root-&gt;left,value);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h1 id="Code-2"><a href="#Code-2" class="headerlink" title="Code 2"></a>Code 2</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * @param root: The root of the binary search tree.</div><div class="line">     * @param value: Remove the node with given value.</div><div class="line">     * @return: The root of the binary search tree after removal.</div><div class="line">     */</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_max</span><span class="params">(TreeNode *cur)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (cur-&gt;right != <span class="literal">NULL</span>)</div><div class="line"><span class="keyword">return</span> get_max(cur-&gt;right);</div><div class="line"></div><div class="line"><span class="keyword">return</span> cur-&gt;val;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="function">TreeNode * <span class="title">removeNode</span><span class="params">(TreeNode * root, <span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (root-&gt;val == value)</div><div class="line">        &#123;</div><div class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> root-&gt;right;</div><div class="line">        <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> root-&gt;left;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> pre = get_max(root-&gt;left);</div><div class="line">        root-&gt;val = pre;</div><div class="line">            root-&gt;left = removeNode(root-&gt;left,pre);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">        <span class="keyword">if</span> (root-&gt;val &lt; value)</div><div class="line">        root-&gt;right = removeNode(root-&gt;right,value);</div><div class="line">        <span class="keyword">else</span></div><div class="line">        root-&gt;left = removeNode(root-&gt;left,value);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Summary&quot;&gt;&lt;a href=&quot;#Problem-Summary&quot; class=&quot;headerlink&quot; title=&quot;Problem Summary&quot;&gt;&lt;/a&gt;Problem Summary&lt;/h1&gt;&lt;p&gt;Given a root of Binary Search Tree with unique value for each node. Remove the node with given value V. If there is no such a node with given value in the binary search tree, do nothing. Remember to keep the tree a binary search tree after removal.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://suzyz.github.io/categories/Algorithm/"/>
    
    
      <category term="LintCode" scheme="https://suzyz.github.io/tags/LintCode/"/>
    
      <category term="Binary Search Tree" scheme="https://suzyz.github.io/tags/Binary-Search-Tree/"/>
    
  </entry>
  
  <entry>
    <title>LintCode/Reorder List</title>
    <link href="https://suzyz.github.io/2017/10/13/reorder-list/"/>
    <id>https://suzyz.github.io/2017/10/13/reorder-list/</id>
    <published>2017-10-13T09:37:10.000Z</published>
    <updated>2017-10-13T10:30:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Summary"><a href="#Problem-Summary" class="headerlink" title="Problem Summary"></a>Problem Summary</h1><p>Given a singly linked list L : L[0] -&gt; L[1] -&gt; … -&gt; L[N-1] -&gt; L[N].<br>Reorder it to : L[0] -&gt; L[N] -&gt; L[1] -&gt; L[N-1] -&gt; L[2] -&gt; L[N-2] -&gt; …</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>First, we find the middle node of list L.<br>We can use two pointers, fast and slow, both initialized with head pointer of list L, to find the middle node in one-pass. Every time the slow pointer moves one step, the fast pointer moves two step. So when the fast pointer or its next reaches the end, the slow pointer is at the middle node.</p><p>Second, we cut list L into two halves, L1 and L2. L1 ends at the middle node and L2 starts at the next node of the middle node. Then we reverse L2, and we use L3 to denote the reversed list.</p><p>Third, we merge L1 and L3.</p><p>The time and space complexities are O(N) and O(1), respectively.</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * @param head: The head of linked list.</div><div class="line">     * @return: nothing</div><div class="line">     */</div><div class="line">    <span class="function">ListNode* <span class="title">reverse_list</span><span class="params">(ListNode * head)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</div><div class="line">            <span class="keyword">return</span> head;</div><div class="line"></div><div class="line">        ListNode *p = head, *q = head-&gt;next, *tmp;</div><div class="line">        <span class="keyword">while</span> (p &amp;&amp; q)</div><div class="line">        &#123;</div><div class="line">            tmp = q-&gt;next;</div><div class="line">            q-&gt;next = p;</div><div class="line"></div><div class="line">            p = q;</div><div class="line">            q = tmp;</div><div class="line">        &#125;</div><div class="line">        head-&gt;next = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">return</span> p;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode * head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        ListNode *fast = head,*slow = head;</div><div class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next)</div><div class="line">        &#123;</div><div class="line">            slow = slow-&gt;next;</div><div class="line">            fast = fast-&gt;next-&gt;next;</div><div class="line">        &#125;</div><div class="line">        ListNode *latter = slow-&gt;next;</div><div class="line">        slow-&gt;next = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">        latter = reverse_list(latter);</div><div class="line"></div><div class="line">        fast = head;</div><div class="line">        ListNode *tmp1,*tmp2;</div><div class="line">        <span class="keyword">while</span> (fast &amp;&amp; latter)</div><div class="line">        &#123;</div><div class="line">            tmp1 = fast-&gt;next;</div><div class="line">            fast-&gt;next = latter;</div><div class="line">            tmp2 = latter-&gt;next;</div><div class="line">            fast = latter-&gt;next = tmp1;</div><div class="line">            latter = tmp2;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Summary&quot;&gt;&lt;a href=&quot;#Problem-Summary&quot; class=&quot;headerlink&quot; title=&quot;Problem Summary&quot;&gt;&lt;/a&gt;Problem Summary&lt;/h1&gt;&lt;p&gt;Given a singly linked list L : L[0] -&amp;gt; L[1] -&amp;gt; … -&amp;gt; L[N-1] -&amp;gt; L[N].&lt;br&gt;Reorder it to : L[0] -&amp;gt; L[N] -&amp;gt; L[1] -&amp;gt; L[N-1] -&amp;gt; L[2] -&amp;gt; L[N-2] -&amp;gt; …&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://suzyz.github.io/categories/Algorithm/"/>
    
    
      <category term="LintCode" scheme="https://suzyz.github.io/tags/LintCode/"/>
    
      <category term="Linked List" scheme="https://suzyz.github.io/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>LintCode/Copy List With Random Pointer</title>
    <link href="https://suzyz.github.io/2017/10/13/copy-list-with-random-pointer/"/>
    <id>https://suzyz.github.io/2017/10/13/copy-list-with-random-pointer/</id>
    <published>2017-10-13T04:12:01.000Z</published>
    <updated>2017-10-13T09:10:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Summary"><a href="#Problem-Summary" class="headerlink" title="Problem Summary"></a>Problem Summary</h1><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p><p>Return a deep copy of the list.</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>First, we make a copy of each node and insert it right after the original node.</p><p>Then, we need to find the “random” pointers for the new nodes.<br>Suppose we have a node p, whose random pointer points to node q, i.e. p-&gt;random == q. And after the copying, we have p-&gt;next == p2, q-&gt;next == q2. Then the random pointer of q1 should be q2. So we let p-&gt;next-&gt;random = p-&gt;random-&gt;next.</p><p>Finally, we break the linked list into two lists, the original one and the copy of it.</p><p>The time complexity is O(N), where N is the length of the linked list.</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for singly-linked list with a random pointer.</div><div class="line"> * struct RandomListNode &#123;</div><div class="line"> *     int label;</div><div class="line"> *     RandomListNode *next, *random;</div><div class="line"> *     RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * @param head: The head of linked list with a random pointer.</div><div class="line">     * @return: A new head of a deep copy of the list.</div><div class="line">     */</div><div class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        RandomListNode *p = head,*tmp;</div><div class="line">        <span class="keyword">while</span> (p)</div><div class="line">        &#123;</div><div class="line">        tmp = p-&gt;next;</div><div class="line">        p-&gt;next = <span class="keyword">new</span> RandomListNode(p-&gt;label);</div><div class="line">        p-&gt;next-&gt;next = tmp;</div><div class="line">        p = p-&gt;next-&gt;next;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        p = head;</div><div class="line">        <span class="keyword">while</span> (p)</div><div class="line">        &#123;</div><div class="line">     <span class="keyword">if</span> (p-&gt;random == <span class="literal">NULL</span>)</div><div class="line">     p-&gt;next-&gt;random = <span class="literal">NULL</span>;</div><div class="line">     <span class="keyword">else</span></div><div class="line">        p-&gt;next-&gt;random = p-&gt;random-&gt;next;</div><div class="line">        p = p-&gt;next-&gt;next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        RandomListNode *res = head-&gt;next;</div><div class="line">        p = head;</div><div class="line">        <span class="keyword">while</span> (p &amp;&amp; p-&gt;next)</div><div class="line">        &#123;</div><div class="line">            tmp = p-&gt;next;</div><div class="line">            p-&gt;next = p-&gt;next-&gt;next;</div><div class="line">            p = tmp;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Summary&quot;&gt;&lt;a href=&quot;#Problem-Summary&quot; class=&quot;headerlink&quot; title=&quot;Problem Summary&quot;&gt;&lt;/a&gt;Problem Summary&lt;/h1&gt;&lt;p&gt;A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.&lt;/p&gt;
&lt;p&gt;Return a deep copy of the list.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://suzyz.github.io/categories/Algorithm/"/>
    
    
      <category term="LintCode" scheme="https://suzyz.github.io/tags/LintCode/"/>
    
      <category term="Linked List" scheme="https://suzyz.github.io/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>LintCode/Sort List</title>
    <link href="https://suzyz.github.io/2017/10/11/sort-list/"/>
    <id>https://suzyz.github.io/2017/10/11/sort-list/</id>
    <published>2017-10-11T15:21:46.000Z</published>
    <updated>2017-10-11T15:41:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Summary"><a href="#Problem-Summary" class="headerlink" title="Problem Summary"></a>Problem Summary</h1><p>Sort a linked list in O(NlogN) time using constant space complexity.</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>I tried merge sort and quick sort. The merge sort worked perfectly, but the quick sort got TLE(time limit exceeded) for some cases.</p><p>When the given list is already ascending or almost in order, the time complexity of quick sort would grow to O(N^2). I haven’t found a way to optimize it yet. If you have any suggestions or would like to discuss with me, please leave a comment or email me, thanks in advance!</p><h1 id="Code-1-Merge-Sort-1"><a href="#Code-1-Merge-Sort-1" class="headerlink" title="Code 1 -  Merge Sort 1"></a>Code 1 -  Merge Sort 1</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> &#123;</span></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">     <span class="keyword">int</span> val;</div><div class="line">     ListNode *next;</div><div class="line">     ListNode(<span class="keyword">int</span> val) &#123;</div><div class="line">         <span class="keyword">this</span>-&gt;val = val;</div><div class="line">         <span class="keyword">this</span>-&gt;next = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * @param head: The head of linked list.</div><div class="line">     * @return: You should return the head of the sorted linked list, using constant space complexity.</div><div class="line">     */</div><div class="line"></div><div class="line"><span class="function">ListNode * <span class="title">merge</span><span class="params">(ListNode *l,ListNode *r)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (l == <span class="literal">NULL</span>)</div><div class="line"><span class="keyword">return</span> r;</div><div class="line"><span class="keyword">if</span> (r == <span class="literal">NULL</span>)</div><div class="line"><span class="keyword">return</span> l;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (l-&gt;val &lt; r-&gt;val)</div><div class="line">&#123;</div><div class="line">l-&gt;next = merge(l-&gt;next,r);</div><div class="line"><span class="keyword">return</span> l;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">r-&gt;next = merge(l,r-&gt;next);</div><div class="line"><span class="keyword">return</span> r;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="function">ListNode * <span class="title">sortList</span><span class="params">(ListNode * head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> head;</div><div class="line">        </div><div class="line">        ListNode *pre = head, *l = head, *r = head;</div><div class="line"><span class="keyword">while</span> (r != <span class="literal">NULL</span> &amp;&amp; r-&gt;next != <span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line">pre = l;</div><div class="line">l = l-&gt;next;</div><div class="line">r = r-&gt;next-&gt;next;</div><div class="line">&#125;</div><div class="line">pre-&gt;next = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line"><span class="keyword">return</span> merge(sortList(head),sortList(l));</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h1 id="Code-2-Merge-Sort-2"><a href="#Code-2-Merge-Sort-2" class="headerlink" title="Code 2 - Merge Sort 2"></a>Code 2 - Merge Sort 2</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition of ListNode</div><div class="line"> * class ListNode &#123;</div><div class="line"> * public:</div><div class="line"> *     int val;</div><div class="line"> *     ListNode *next;</div><div class="line"> *     ListNode(int val) &#123;</div><div class="line"> *         this-&gt;val = val;</div><div class="line"> *         this-&gt;next = NULL;</div><div class="line"> *     &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * @param head: The head of linked list.</div><div class="line">     * @return: You should return the head of the sorted linked list, using constant space complexity.</div><div class="line">     */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_free</span><span class="params">(ListNode *p)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (p==<span class="literal">NULL</span>)</div><div class="line"><span class="keyword">return</span>;</div><div class="line">set_free(p-&gt;next);</div><div class="line"><span class="keyword">delete</span> p;</div><div class="line">&#125;</div><div class="line"><span class="function">ListNode * <span class="title">merge</span><span class="params">(ListNode *l,ListNode *r)</span></span></div><div class="line">&#123;</div><div class="line">ListNode *p = l, *q = r;</div><div class="line">ListNode *res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">ListNode *head = res;</div><div class="line"></div><div class="line"><span class="keyword">while</span> (p!= <span class="literal">NULL</span> &amp;&amp; q!= <span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (p-&gt;val &lt; q-&gt;val)</div><div class="line">&#123;</div><div class="line">res-&gt;next = <span class="keyword">new</span> ListNode(p-&gt;val);</div><div class="line">p = p-&gt;next;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">res-&gt;next = <span class="keyword">new</span> ListNode(q-&gt;val);</div><div class="line">q = q-&gt;next;</div><div class="line">&#125;</div><div class="line">res = res-&gt;next;</div><div class="line">&#125;</div><div class="line"><span class="keyword">while</span> (p!=<span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line">res-&gt;next = <span class="keyword">new</span> ListNode(p-&gt;val);</div><div class="line">res = res-&gt;next;</div><div class="line">p = p-&gt;next;</div><div class="line">&#125;</div><div class="line"><span class="keyword">while</span> (q!=<span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line">res-&gt;next = <span class="keyword">new</span> ListNode(q-&gt;val);</div><div class="line">res = res-&gt;next;</div><div class="line">q = q-&gt;next;</div><div class="line">&#125;</div><div class="line"></div><div class="line">set_free(l);</div><div class="line">set_free(r);</div><div class="line"><span class="keyword">return</span> head-&gt;next;</div><div class="line">&#125;</div><div class="line"><span class="function">ListNode * <span class="title">merge_sort</span><span class="params">(ListNode *head,<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (n&lt;=<span class="number">1</span>)</div><div class="line"><span class="keyword">return</span> head;</div><div class="line"></div><div class="line">ListNode *pre = head, *mid = head;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">2</span>; ++i)</div><div class="line">&#123;</div><div class="line">pre = mid;</div><div class="line">mid = mid-&gt;next;</div><div class="line">&#125;</div><div class="line">pre-&gt;next = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">ListNode *l = merge_sort(head,n/<span class="number">2</span>);</div><div class="line">ListNode *r = merge_sort(mid,n-n/<span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="keyword">return</span> merge(l,r);</div><div class="line">&#125;</div><div class="line">    <span class="function">ListNode * <span class="title">sortList</span><span class="params">(ListNode * head)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        ListNode *p = head;</div><div class="line">        <span class="keyword">while</span> (p)</div><div class="line">        &#123;</div><div class="line">        ++n;</div><div class="line">        p = p-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> merge_sort(head,n);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h1 id="Code-3-Quick-Sort"><a href="#Code-3-Quick-Sort" class="headerlink" title="Code 3 - Quick Sort"></a>Code 3 - Quick Sort</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * @param head: The head of linked list.</div><div class="line">     * @return: You should return the head of the sorted linked list, using constant space complexity.</div><div class="line">     */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_list_free</span><span class="params">(ListNode * head)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line"><span class="keyword">return</span>;</div><div class="line">set_list_free(head-&gt;next);</div><div class="line"><span class="keyword">delete</span> head;</div><div class="line">&#125;</div><div class="line">    <span class="function">ListNode * <span class="title">sortList</span><span class="params">(ListNode * head)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> head;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> v = head-&gt;val;</div><div class="line">        ListNode *left = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode *right = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode *p = left, *q = right;</div><div class="line">        ListNode *cur = head-&gt;next;</div><div class="line"></div><div class="line">       <span class="keyword">while</span>(cur)</div><div class="line">       &#123;</div><div class="line">       <span class="keyword">if</span> (cur-&gt;val &lt; v)</div><div class="line">       &#123;</div><div class="line">       p-&gt;next = <span class="keyword">new</span> ListNode(cur-&gt;val);</div><div class="line">       p = p-&gt;next;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">else</span></div><div class="line">       &#123;</div><div class="line">       q-&gt;next = <span class="keyword">new</span> ListNode(cur-&gt;val);</div><div class="line">       q = q-&gt;next;</div><div class="line">       &#125;</div><div class="line">       cur = cur-&gt;next;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       set_list_free(head);</div><div class="line"></div><div class="line">       cur = sortList(left-&gt;next);</div><div class="line">       <span class="keyword">delete</span> left;</div><div class="line">       left = cur;</div><div class="line"></div><div class="line">       cur = sortList(right-&gt;next);</div><div class="line">       <span class="keyword">delete</span> right;</div><div class="line">       right = <span class="keyword">new</span> ListNode(v);</div><div class="line">right-&gt;next = cur;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (left == <span class="literal">NULL</span>)</div><div class="line">       <span class="keyword">return</span> right;</div><div class="line"></div><div class="line">        ListNode *pre = left;</div><div class="line">        cur = left;</div><div class="line">        <span class="keyword">while</span> (cur)</div><div class="line">        &#123;</div><div class="line">        pre = cur;</div><div class="line">        cur = cur-&gt;next;</div><div class="line">        &#125;</div><div class="line">       pre-&gt;next = right;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> left;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Summary&quot;&gt;&lt;a href=&quot;#Problem-Summary&quot; class=&quot;headerlink&quot; title=&quot;Problem Summary&quot;&gt;&lt;/a&gt;Problem Summary&lt;/h1&gt;&lt;p&gt;Sort a linked list in O(NlogN) time using constant space complexity.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://suzyz.github.io/categories/Algorithm/"/>
    
    
      <category term="LintCode" scheme="https://suzyz.github.io/tags/LintCode/"/>
    
      <category term="Sort" scheme="https://suzyz.github.io/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>LintCode/Gas Station</title>
    <link href="https://suzyz.github.io/2017/10/10/gas-station/"/>
    <id>https://suzyz.github.io/2017/10/10/gas-station/</id>
    <published>2017-10-10T04:50:02.000Z</published>
    <updated>2017-10-10T06:55:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Summary"><a href="#Problem-Summary" class="headerlink" title="Problem Summary"></a>Problem Summary</h1><p>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].</p><p>You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.</p><p>Find the index of the starting gas station if you can travel around the circuit once, otherwise return -1.<br>The solution is guaranteed to be unique.</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>Fisrt, let us use diff[i] to denote the amount of gas left if we go to station (i+1) from station i. Apparently, diff[i] = gas[i] - cost[i].</p><p>Let sum[i,j] = diff[i] + diff[i+1] + … + diff[j], total = sum[0,N-1].</p><p>If there is a feasible solution i, it should satisfy that</p><blockquote><p>sum[i,j] &ge; 0, j = i+1,i+2,…,N-1,0,1,…,i-1. &nbsp; &nbsp; &nbsp; &nbsp; (1)</p></blockquote><p>Apparently, there is no feasible solution if total is negative. But if total &ge; 0, can we say for sure that there is a solution?</p><p>Well, we can prove that</p><blockquote><p>if total &ge; 0, there exits an index i such that (1) holds. (2)</p></blockquote><p>So if total &ge; 0, there must be an answer. Now let us think greedily.<br>Suppose we begin the journey at j. If we find sum[j,j+k] &ge; 0, but sum[j,j+k+1] &lt; 0, then j is definitely not the answer. Actually, it is unnecessary to consider j+1, j+2, …, j+k+1, either. So we move to consider j’ = j+k+2.<br>In this way we can find the answer in O(N) time.</p><h2 id="Proof-of-2"><a href="#Proof-of-2" class="headerlink" title="Proof of (2)"></a>Proof of (2)</h2><p>Let’s assume that</p><blockquote><p>total &ge; 0 but (1) does not hold for any i, 0 &le; i &le; N-1. &nbsp;(3)</p></blockquote><p>The for 0 we have an index p[0] &gt; 0, s.t. sum[0,p[0]] &lt; 0. Since total &ge; 0, we know that p[0] &ne; N-1. Let us suppose p[0] is the first index that satisfies sum[0,i] &lt; 0.</p><p>Because of (3), there exits an index p[1] s.t. sum[p[0],p[1]] &lt; 0.<br>If 0 &le; p[1] &lt; p[0], we have sum[0,p[0]] + sum[p[0],p[1]] = total + sum[0,p[1]], hence sum[0,p[1]] &lt; 0. So p[0] &lt; p[1] &lt; N-1.</p><p>Similiarly, we can find infinite indices p[2],p[3],p[4],… s.t. p[0] &lt; p[1] &lt; p[2] &lt; p[3] &lt; …<br>But the diff array is finite. With this contradiction, we know that (3) is false, so (2) is true.</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * @param gas: An array of integers</div><div class="line">     * @param cost: An array of integers</div><div class="line">     * @return: An integer</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;cost)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = gas.size();</div><div class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> total = <span class="number">0</span>, sum = <span class="number">0</span>, st = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">        &#123;</div><div class="line">        <span class="keyword">int</span> cur = gas[i] - cost[i];</div><div class="line">        total += cur;</div><div class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">        sum = cur;</div><div class="line">        st = i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        sum += cur;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> total &lt; <span class="number">0</span> ? <span class="number">-1</span> : st;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Summary&quot;&gt;&lt;a href=&quot;#Problem-Summary&quot; class=&quot;headerlink&quot; title=&quot;Problem Summary&quot;&gt;&lt;/a&gt;Problem Summary&lt;/h1&gt;&lt;p&gt;There are N gas stations along a circular route, where the amount of gas at station i is gas[i].&lt;/p&gt;
&lt;p&gt;You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.&lt;/p&gt;
&lt;p&gt;Find the index of the starting gas station if you can travel around the circuit once, otherwise return -1.&lt;br&gt;The solution is guaranteed to be unique.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://suzyz.github.io/categories/Algorithm/"/>
    
    
      <category term="LintCode" scheme="https://suzyz.github.io/tags/LintCode/"/>
    
      <category term="Greedy" scheme="https://suzyz.github.io/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>HackerRank/Merge Sort/Counting Inversions</title>
    <link href="https://suzyz.github.io/2017/10/08/merge-sort-counting-inversions/"/>
    <id>https://suzyz.github.io/2017/10/08/merge-sort-counting-inversions/</id>
    <published>2017-10-08T09:16:27.000Z</published>
    <updated>2017-10-08T09:55:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Summary"><a href="#Problem-Summary" class="headerlink" title="Problem Summary"></a>Problem Summary</h1><p>Given an array of N integers, calculate the number of swaps you need to perfom to sort the array in ascending order. You can only swap adjacent elements.</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>We use merge sort to solve this problem. During each merging process, we count the number of swaps. And we get the sum recursively.</p><p>Note that we can only swap adjacent elements. So moving an integer from position j to position i requires i-j swaps.</p><p>A trick for saving time :<br>We can use two arrays A and B, to store the data, and if this time we perfom the merge function from A to B, the next time we perfom it from B to A. In this way we do not have to copy the array every time.</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line">const int maxn = 100010;</div><div class="line"></div><div class="line">int n,arr[maxn],aux[maxn];</div><div class="line"></div><div class="line">long long merge(int (&amp;s)[maxn],int (&amp;t)[maxn],int st,int mid,int en)</div><div class="line">&#123;</div><div class="line">    int i = st, j = mid+1, idx = st;</div><div class="line">    long long res = 0;</div><div class="line">    while (i&lt;=mid &amp;&amp; j&lt;=en)</div><div class="line">    &#123;</div><div class="line">        if (s[i] &lt;= s[j])</div><div class="line">            t[idx++] = s[i++];</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            t[idx++] = s[j++];</div><div class="line">            res += mid+1 - i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    while (i&lt;=mid)</div><div class="line">    &#123;</div><div class="line">        t[idx++] = s[i++];</div><div class="line">    &#125;</div><div class="line">    while (j&lt;=en)</div><div class="line">    &#123;</div><div class="line">        t[idx++] = s[j++];</div><div class="line">    &#125;</div><div class="line">    return res;</div><div class="line">&#125;</div><div class="line"></div><div class="line">long long merge_sort(int (&amp;s)[maxn],int (&amp;t)[maxn],int st,int en)</div><div class="line">&#123;</div><div class="line">    if (st &gt;= en)</div><div class="line">        return 0;</div><div class="line"></div><div class="line">    long long count = 0;</div><div class="line">    int mid = st + ((en-st)&gt;&gt;1);</div><div class="line">    count += merge_sort (t,s,st,mid);</div><div class="line">    count += merge_sort (t,s,mid+1,en);</div><div class="line"></div><div class="line">    count += merge(s,t,st,mid,en);</div><div class="line">    return count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    </div><div class="line">    int Q;</div><div class="line">    cin &gt;&gt; Q;</div><div class="line"></div><div class="line">while (Q--)</div><div class="line">&#123;</div><div class="line">    int n;</div><div class="line">    cin &gt;&gt; n;</div><div class="line">    for (int i = 0; i &lt; n; ++i)</div><div class="line">    &#123;</div><div class="line">        cin &gt;&gt; arr[i];</div><div class="line">        aux[i] = arr[i];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    cout &lt;&lt; merge_sort(arr,aux,0,n-1) &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Summary&quot;&gt;&lt;a href=&quot;#Problem-Summary&quot; class=&quot;headerlink&quot; title=&quot;Problem Summary&quot;&gt;&lt;/a&gt;Problem Summary&lt;/h1&gt;&lt;p&gt;Given an array of N integers, calculate the number of swaps you need to perfom to sort the array in ascending order. You can only swap adjacent elements.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://suzyz.github.io/categories/Algorithm/"/>
    
    
      <category term="HackerRank" scheme="https://suzyz.github.io/tags/HackerRank/"/>
    
      <category term="Sort" scheme="https://suzyz.github.io/tags/Sort/"/>
    
      <category term="Merge Sort" scheme="https://suzyz.github.io/tags/Merge-Sort/"/>
    
  </entry>
  
</feed>
