<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Suzy Zhang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://suzyz.github.io/"/>
  <updated>2017-11-19T09:21:22.000Z</updated>
  <id>https://suzyz.github.io/</id>
  
  <author>
    <name>Suzy Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode/Validate Binary Search Tree</title>
    <link href="https://suzyz.github.io/2017/11/19/validate-binary-search-tree2/"/>
    <id>https://suzyz.github.io/2017/11/19/validate-binary-search-tree2/</id>
    <published>2017-11-19T08:52:43.000Z</published>
    <updated>2017-11-19T09:21:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Summary"><a href="#Problem-Summary" class="headerlink" title="Problem Summary"></a>Problem Summary</h1><p>Given a binary tree, determine if it is a binary search tree.</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>I have wrote about this problem before: <a href="https://suzyz.github.io/2017/10/14/validate-binary-search-tree/">https://suzyz.github.io/2017/10/14/validate-binary-search-tree/</a></p><p>Now I would like to implement Solution 2 in that post. That is, carry out an inorder traversal with the help of a stack.</p><p>It is relatively harder to code, but not much work actually.</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; st;</div><div class="line">        TreeNode *pre = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span> || !st.empty())</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">while</span> (root != <span class="literal">NULL</span>)</div><div class="line">            &#123;</div><div class="line">                st.push(root);</div><div class="line">                root = root-&gt;left;</div><div class="line">            &#125;</div><div class="line">            TreeNode *cur = st.top();</div><div class="line">            st.pop();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; cur-&gt;val &lt;= pre-&gt;val)</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">            pre = cur;</div><div class="line">            root = cur-&gt;right;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Summary&quot;&gt;&lt;a href=&quot;#Problem-Summary&quot; class=&quot;headerlink&quot; title=&quot;Problem Summary&quot;&gt;&lt;/a&gt;Problem Summary&lt;/h1&gt;&lt;p&gt;Given a binary tree, determine if it is a binary search tree.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://suzyz.github.io/categories/Algorithm/"/>
    
    
      <category term="LeetCode" scheme="https://suzyz.github.io/tags/LeetCode/"/>
    
      <category term="Binary Search Tree" scheme="https://suzyz.github.io/tags/Binary-Search-Tree/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode/Happy Number</title>
    <link href="https://suzyz.github.io/2017/11/13/happy-number/"/>
    <id>https://suzyz.github.io/2017/11/13/happy-number/</id>
    <published>2017-11-13T12:08:08.000Z</published>
    <updated>2017-11-13T12:31:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Summary"><a href="#Problem-Summary" class="headerlink" title="Problem Summary"></a>Problem Summary</h1><p>Write an algorithm to determine if a number is “happy”.</p><a id="more"></a><p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p><p>Example: 19 is a happy number</p><p>1^2 + 9^2 = 82<br>8^2 + 2^2 = 68<br>6^2 + 8^2 = 100<br>1^2 + 0^2 + 0^2 = 1</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>At first I used a hash table (unordered_set in STL) to record the numbers and find loops (see Code 2). But this takes extra space and is slower than Floyd’s cycle-finding algorithm. You can find the definition on Wikipedia (<a href="https://en.wikipedia.org/wiki/Cycle_detection#Floyd.27s_Tortoise_and_Hare" target="_blank" rel="external">Floyd’s cycle-finding algorithm</a>).</p><p>The algorithm works with two “pointers”, A and B. A moves twice faster than B. So if there is any loop, A and B will finally meet. In this problem, 1 leads to 1, so they will meet whether the number is happy or not.</p><h1 id="Code-1-With-Floyd’s-cycle-finding-algorithm"><a href="#Code-1-With-Floyd’s-cycle-finding-algorithm" class="headerlink" title="Code 1: With Floyd’s cycle-finding algorithm"></a>Code 1: With Floyd’s cycle-finding algorithm</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> slow = digit_square(n);</div><div class="line">        <span class="keyword">int</span> fast = digit_square(slow);</div><div class="line">        <span class="keyword">while</span> (slow != fast)</div><div class="line">        &#123;</div><div class="line">        slow = digit_square(slow);</div><div class="line">            fast = digit_square(digit_square(fast));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (slow == <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">digit_square</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>,tmp;</div><div class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            tmp = n%<span class="number">10</span>;</div><div class="line">            sum += tmp*tmp;</div><div class="line">            n/=<span class="number">10</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h1 id="Code-2-With-hash-table"><a href="#Code-2-With-hash-table" class="headerlink" title="Code 2: With hash table"></a>Code 2: With hash table</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; vis;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</div><div class="line">        &#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>,tmp;</div><div class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">        tmp = n%<span class="number">10</span>;</div><div class="line">        sum += tmp*tmp;</div><div class="line">        n/=<span class="number">10</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (sum == <span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span> (vis.count(sum))</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">        vis.insert(sum);</div><div class="line">        n = sum;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Summary&quot;&gt;&lt;a href=&quot;#Problem-Summary&quot; class=&quot;headerlink&quot; title=&quot;Problem Summary&quot;&gt;&lt;/a&gt;Problem Summary&lt;/h1&gt;&lt;p&gt;Write an algorithm to determine if a number is “happy”.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://suzyz.github.io/categories/Algorithm/"/>
    
    
      <category term="LeetCode" scheme="https://suzyz.github.io/tags/LeetCode/"/>
    
      <category term="Graph Theory" scheme="https://suzyz.github.io/tags/Graph-Theory/"/>
    
      <category term="Cycle Detection" scheme="https://suzyz.github.io/tags/Cycle-Detection/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode/Minimum Height Tree</title>
    <link href="https://suzyz.github.io/2017/11/12/minimum-height-tree/"/>
    <id>https://suzyz.github.io/2017/11/12/minimum-height-tree/</id>
    <published>2017-11-12T01:39:27.000Z</published>
    <updated>2017-11-14T15:26:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Summary"><a href="#Problem-Summary" class="headerlink" title="Problem Summary"></a>Problem Summary</h1><p>For an undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, find all roots of the MHTs.</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>There is a great analysis on LeetCode:</p><p> <a href="https://discuss.leetcode.com/topic/30572/share-some-thoughts" target="_blank" rel="external">https://discuss.leetcode.com/topic/30572/share-some-thoughts</a></p><p>I tried a few ways to solve the problem, but mostly ended with TLE (time limit exceeded). Then I read the article mentioned, and felt really inspired.</p><p>I realize that it is important to start analyzing the problem from simple cases. For example, consider line graphs before getting to more complicated graphs.</p><p>Line graphs look like doubly linked lists. So the root(s) of MHT is the node at the middle of the graph. We can use two pointers to find it. Let each pointer start from one end of the graph and move at the same speed, until they meet or they are next to each other.</p><p>With more complex graphs, we need K pointers, if the graph has K leaves(nodes whose degree is 1). We let them move at the same speed towards the center of the graph. When two or more pointers meet, we merge them and keep going. When the pointers meet or are next to each other (in which case there are only two pointers left), we find the root(s).</p><p>The process looks like peeling an apple. Or, keep peeling leaves from a “tree”. So when it comes to implementation, we can use topological sort to simulate it.</p><p>Plus, there is a little trick with regard to coding. When we iterate through the leaves, we only need to update the information of one node since any leave only connects to one node. That is the difference between Code 1 and Code 2.</p><h1 id="Code-1"><a href="#Code-1" class="headerlink" title="Code 1"></a>Code 1</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findMinHeightTrees(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;&amp; edges) &#123;</div><div class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (edges.size() == <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">0</span>);</div><div class="line">        <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; g(n);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); ++i)</div><div class="line">        &#123;</div><div class="line">        <span class="keyword">int</span> a = edges[i].first, b = edges[i].second;</div><div class="line">        g[a].insert(b);</div><div class="line">        g[b].insert(a);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; leaves;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">        <span class="keyword">if</span> (g[i].size() == <span class="number">1</span>)</div><div class="line">        leaves.push_back(i);</div><div class="line">        </div><div class="line">        n -= leaves.size();</div><div class="line">        <span class="keyword">while</span> (n)</div><div class="line">        &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; new_leaves;</div><div class="line">       </div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leaves.size(); ++i)</div><div class="line">       &#123;</div><div class="line">       <span class="keyword">int</span> cur = leaves[i];</div><div class="line">       <span class="keyword">for</span> (<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;::iterator j = g[cur].begin(); j != g[cur].end(); )</div><div class="line">        &#123;</div><div class="line">        g[*j].erase(cur);</div><div class="line">        <span class="keyword">if</span> (g[*j].size() == <span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">        new_leaves.push_back(*j);</div><div class="line">        j = g[cur].erase(j);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        ++j;</div><div class="line">        &#125;</div><div class="line">       &#125;</div><div class="line">        leaves = new_leaves;</div><div class="line">        n -= leaves.size();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> leaves;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h1 id="Code-2"><a href="#Code-2" class="headerlink" title="Code 2"></a>Code 2</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findMinHeightTrees(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;&amp; edges) &#123;</div><div class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (edges.size() == <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">0</span>);</div><div class="line">        <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; g(n);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); ++i)</div><div class="line">        &#123;</div><div class="line">        <span class="keyword">int</span> a = edges[i].first, b = edges[i].second;</div><div class="line">        g[a].insert(b);</div><div class="line">        g[b].insert(a);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; leaves;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">        <span class="keyword">if</span> (g[i].size() == <span class="number">1</span>)</div><div class="line">        leaves.push_back(i);</div><div class="line">        </div><div class="line">        n -= leaves.size();</div><div class="line">        <span class="keyword">while</span> (n)</div><div class="line">        &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; new_leaves;</div><div class="line">       </div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leaves.size(); ++i)</div><div class="line">       &#123;</div><div class="line">       <span class="keyword">int</span> cur = leaves[i];</div><div class="line"></div><div class="line">                <span class="comment">/* Because cur is a leaf, it is only connected to one other node. */</span></div><div class="line">                <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;::iterator j = g[cur].begin();</div><div class="line">       </div><div class="line">        g[*j].erase(cur);</div><div class="line">        <span class="keyword">if</span> (g[*j].size() == <span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">        new_leaves.push_back(*j);</div><div class="line">        g[cur].erase(j);</div><div class="line">        &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">        leaves = new_leaves;</div><div class="line">        n -= leaves.size();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> leaves;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Summary&quot;&gt;&lt;a href=&quot;#Problem-Summary&quot; class=&quot;headerlink&quot; title=&quot;Problem Summary&quot;&gt;&lt;/a&gt;Problem Summary&lt;/h1&gt;&lt;p&gt;For an undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, find all roots of the MHTs.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://suzyz.github.io/categories/Algorithm/"/>
    
    
      <category term="LeetCode" scheme="https://suzyz.github.io/tags/LeetCode/"/>
    
      <category term="Tree" scheme="https://suzyz.github.io/tags/Tree/"/>
    
      <category term="Topological Sorting" scheme="https://suzyz.github.io/tags/Topological-Sorting/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode/Recover Binary Search Tree</title>
    <link href="https://suzyz.github.io/2017/11/11/recover-binary-search-tree/"/>
    <id>https://suzyz.github.io/2017/11/11/recover-binary-search-tree/</id>
    <published>2017-11-11T07:58:50.000Z</published>
    <updated>2017-11-11T09:23:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Summary"><a href="#Problem-Summary" class="headerlink" title="Problem Summary"></a>Problem Summary</h1><p>Two elements of a binary search tree are swapped. Recover the tree by swapping them again.</p><a id="more"></a><h1 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h1><p>We can get the inorder traversal of the tree, and then the two nodes needed are easy to find. The time and space complexities are both O(N).</p><h1 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h1><p>Suppose the two swapped nodes are i and j, their values being vi and vj (vi &gt; vj). Then there are two possible situations:</p><ol><li><p>i and j are adjacent in the inorder traversal of the tree.</p></li><li><p>Otherwise, there would be two nodes x and y, whose values being vx and vy, such that x is the successor of i in the inorder traversal, and y is the predecessor of j.</p></li></ol><p>To find i and j, we use inorder traversal.<br>We can use two pointers p and q to remember the pointers to i and j, and a pointer pre to remember the predecessor of the current node. During the traversal, if we find that pre-&gt;val &gt; cur-&gt;val, then we check p. If p has not been assigned with any value, we let p = pre and q = cur; else, we only let q = cur.<br>After the search, we switch the two nodes that p and q point to.</p><p>The time complexity of this method is also O(N), but the space it requires is only O(1).</p><h1 id="Code-for-Solution-2"><a href="#Code-for-Solution-2" class="headerlink" title="Code for Solution 2"></a>Code for Solution 2</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    TreeNode *p = <span class="literal">NULL</span>, *q = <span class="literal">NULL</span>, *pre = <span class="literal">NULL</span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    dfs(root);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (p &amp;&amp; q)</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">int</span> tmp = p-&gt;val;</div><div class="line">    p-&gt;val = q-&gt;val;</div><div class="line">    q-&gt;val = tmp;</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode *root)</span></span></div><div class="line">    &#123;</div><div class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    dfs(root-&gt;left);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; root-&gt;val &lt; pre-&gt;val)</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</div><div class="line">    &#123;</div><div class="line">    p = pre;</div><div class="line">    q = root;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    q = root;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    pre = root;</div><div class="line">    dfs(root-&gt;right);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Summary&quot;&gt;&lt;a href=&quot;#Problem-Summary&quot; class=&quot;headerlink&quot; title=&quot;Problem Summary&quot;&gt;&lt;/a&gt;Problem Summary&lt;/h1&gt;&lt;p&gt;Two elements of a binary search tree are swapped. Recover the tree by swapping them again.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://suzyz.github.io/categories/Algorithm/"/>
    
    
      <category term="LeetCode" scheme="https://suzyz.github.io/tags/LeetCode/"/>
    
      <category term="DFS" scheme="https://suzyz.github.io/tags/DFS/"/>
    
      <category term="Binary Search Tree" scheme="https://suzyz.github.io/tags/Binary-Search-Tree/"/>
    
  </entry>
  
  <entry>
    <title>LintCode/Wiggle Sort</title>
    <link href="https://suzyz.github.io/2017/11/11/wiggle-sort/"/>
    <id>https://suzyz.github.io/2017/11/11/wiggle-sort/</id>
    <published>2017-11-11T06:53:44.000Z</published>
    <updated>2017-11-11T07:11:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Summary"><a href="#Problem-Summary" class="headerlink" title="Problem Summary"></a>Problem Summary</h1><p>Given an unsorted array A, reorder it in-place such that A[0] &lt;= A[1] &gt;= A[2] &lt;= A[3]…</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>We can sort the array then reorder it, of course. But it would take us O(N) time. Let us consider whether we can solve this in linear time.</p><p>Suppose we iterate through the array and are currently at A[i], with A[0] to A[i-1] already “sorted”.<br>If i is odd and A[i] &ge; A[i-1] (or i is even and A[i] &le; A[i-1]), then we can move on to A[i+1].<br>If not, we need to switch A[i] with A[i-1]. And this will not damage the work already done: if i is odd and A[i] &lt; A[i-1], we also have A[i-2] &ge; A[i-1], so A[i-2] &ge; A[i-1] &gt; A[i]. That is, the order between the (i-2)th number and (i-1)th number still maintains after the swith.</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * @param nums: A list of integers</div><div class="line">     * @return: nothing</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = nums.size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i)</div><div class="line">    <span class="keyword">if</span> ((i%<span class="number">2</span> &amp;&amp; nums[i] &lt; nums[i+<span class="number">1</span>]) || (!(i%<span class="number">2</span>) &amp;&amp; nums[i] &gt; nums[i+<span class="number">1</span>]))</div><div class="line">    swap(nums[i],nums[i+<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Summary&quot;&gt;&lt;a href=&quot;#Problem-Summary&quot; class=&quot;headerlink&quot; title=&quot;Problem Summary&quot;&gt;&lt;/a&gt;Problem Summary&lt;/h1&gt;&lt;p&gt;Given an unsorted array A, reorder it in-place such that A[0] &amp;lt;= A[1] &amp;gt;= A[2] &amp;lt;= A[3]…&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://suzyz.github.io/categories/Algorithm/"/>
    
    
      <category term="Array" scheme="https://suzyz.github.io/tags/Array/"/>
    
      <category term="LintCode" scheme="https://suzyz.github.io/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>LintCode/Sliding Window Unique Elements Sum</title>
    <link href="https://suzyz.github.io/2017/11/11/sliding-window-unique-elements-sum/"/>
    <id>https://suzyz.github.io/2017/11/11/sliding-window-unique-elements-sum/</id>
    <published>2017-11-11T06:18:56.000Z</published>
    <updated>2017-11-11T06:35:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Summary"><a href="#Problem-Summary" class="headerlink" title="Problem Summary"></a>Problem Summary</h1><p>Given an array and a window size that is sliding along the array, find the sum of the numbers of unique elements in each window.</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>We can use the container “unoreder_map” in STL to help us calculate the frequencies of numbers in the current window. It is actually using hash map (or hash table) to keep record of values, so the time complexity is O(N).</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * @param : the given array</div><div class="line">     * @param : the window size</div><div class="line">     * @return: the sum of the count of unique elements in each window</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">slidingWindowUniqueElementsSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = nums.size();</div><div class="line">    <span class="keyword">if</span> (n &lt; k)</div><div class="line">    k = n;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</div><div class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; count;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</div><div class="line">    ++count[nums[i]];</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it = count.begin(); it != count.end(); ++it)</div><div class="line">    <span class="keyword">if</span> (it-&gt;second == <span class="number">1</span>)</div><div class="line">    ++ans;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; ++i)</div><div class="line">    &#123;</div><div class="line">    --count[nums[i-k]];</div><div class="line">    ++count[nums[i]];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (count[nums[i-k]] == <span class="number">0</span>)</div><div class="line">    count.erase(nums[i-k]);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it = count.begin(); it != count.end(); ++it)</div><div class="line">    <span class="keyword">if</span> (it-&gt;second == <span class="number">1</span>)</div><div class="line">    ++ans;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Summary&quot;&gt;&lt;a href=&quot;#Problem-Summary&quot; class=&quot;headerlink&quot; title=&quot;Problem Summary&quot;&gt;&lt;/a&gt;Problem Summary&lt;/h1&gt;&lt;p&gt;Given an array and a window size that is sliding along the array, find the sum of the numbers of unique elements in each window.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://suzyz.github.io/categories/Algorithm/"/>
    
    
      <category term="Array" scheme="https://suzyz.github.io/tags/Array/"/>
    
      <category term="LintCode" scheme="https://suzyz.github.io/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>LintCode/LRU Cache</title>
    <link href="https://suzyz.github.io/2017/11/05/lru-cache/"/>
    <id>https://suzyz.github.io/2017/11/05/lru-cache/</id>
    <published>2017-11-05T12:48:55.000Z</published>
    <updated>2017-11-05T13:42:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Summary"><a href="#Problem-Summary" class="headerlink" title="Problem Summary"></a>Problem Summary</h1><p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set.</p><a id="more"></a><ul><li><p>get(key) : Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.</p></li><li><p>set(key, value) : Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p></li></ul><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>We can use linked list together with unordered map to solve this problem. </p><p>First, we use a linked list L to record pairs of keys and values. Each time we insert a new pair (key,value), we use the map to mark the position of it.</p><p>Then, for each get(key) operation, we can locate the pair (key,value) using the map in O(1) time. We also need to move the pair to the beginning of the linked list, since it is just used. Don’t forget to modify map[key] as the position of pair (key,value) changed.</p><p>As for the set(key,value) operation,</p><ol><li>If (key,previous_value) already exits in the list, we erase it and insert the new pair.</li><li>If key is not already present, we need to check the capacity first. If the cache has reached its capacity, we erase the least recently used item, i.e. the pair at the end of the linked list. Then we insert the new pair to the beginning.<br>And of course, we need to maintain the map in the above process.</li></ol><p>The time complexities of get and set operations are both O(1), since the map is unordered.</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> cap, used;</div><div class="line">    <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; l;</div><div class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;::iterator&gt; position;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">    * @param capacity: An integer</div><div class="line">    */</div><div class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</div><div class="line">        cap = capacity;</div><div class="line">        used = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * @param key: An integer</div><div class="line">     * @return: An integer</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(position.count(key) == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;::iterator it = position[key];</div><div class="line">            <span class="keyword">int</span> res = (*it).second;</div><div class="line">            <span class="keyword">if</span> (it != l.begin())</div><div class="line">            &#123;</div><div class="line">                l.insert(l.begin(),make_pair(key,res));</div><div class="line">                l.erase(it);</div><div class="line">                position[key] = l.begin();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> res;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * @param key: An integer</div><div class="line">     * @param value: An integer</div><div class="line">     * @return: nothing</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (cap &lt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (position.count(key) == <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (used &gt;= cap)</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;::iterator it = l.end();</div><div class="line">                --it;</div><div class="line">                position.erase((*it).first);</div><div class="line">                l.erase(it);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                ++used;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;::iterator it = position[key];</div><div class="line">            l.erase(it);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        l.insert(l.begin(),make_pair(key,value));</div><div class="line">        position[key] = l.begin();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Summary&quot;&gt;&lt;a href=&quot;#Problem-Summary&quot; class=&quot;headerlink&quot; title=&quot;Problem Summary&quot;&gt;&lt;/a&gt;Problem Summary&lt;/h1&gt;&lt;p&gt;Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://suzyz.github.io/categories/Algorithm/"/>
    
    
      <category term="LintCode" scheme="https://suzyz.github.io/tags/LintCode/"/>
    
      <category term="Linked List" scheme="https://suzyz.github.io/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>LintCode/Top K Frequent Words</title>
    <link href="https://suzyz.github.io/2017/11/05/top-k-frequent-words/"/>
    <id>https://suzyz.github.io/2017/11/05/top-k-frequent-words/</id>
    <published>2017-11-05T12:23:26.000Z</published>
    <updated>2017-11-05T14:24:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Summary"><a href="#Problem-Summary" class="headerlink" title="Problem Summary"></a>Problem Summary</h1><p>Find top k frequent words with map reduce framework.</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>With map reduce, we only need to implement the mapper and the reducer.</p><p>The mapper part is easy to code. Note that there may be more than one consecutive spaces in the input. As for the reducer, we calculate the frequency of each word and push the pair (word,frequency) into a priority queue, i.e. a heap. After the reduce is done, we pop k pairs from the heap.</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Definition of Input:</div><div class="line"> * template&lt;class T&gt;</div><div class="line"> * class Input &#123;</div><div class="line"> * public:</div><div class="line"> *     bool done(); </div><div class="line"> *         // Returns true if the iteration has elements or false.</div><div class="line"> *     void next();</div><div class="line"> *         // Move to the next element in the iteration</div><div class="line"> *         // Runtime error if the iteration has no more elements</div><div class="line"> *     T value();</div><div class="line"> *        // Get the current element, Runtime error if</div><div class="line"> *        // the iteration has no more elements</div><div class="line"> * &#125;</div><div class="line"> * Definition of Document:</div><div class="line"> * class Document &#123;</div><div class="line"> * public:</div><div class="line"> *     int id; // document id</div><div class="line"> *     string content; // document content</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopKFrequentWordsMapper</span>:</span> <span class="keyword">public</span> Mapper &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Map</span><span class="params">(Input&lt;Document&gt;* input)</span> </span>&#123;</div><div class="line">        <span class="comment">// Write your code here</span></div><div class="line">        <span class="comment">// Please directly use func 'output' to output </span></div><div class="line">        <span class="comment">// the results into output buffer.</span></div><div class="line">        <span class="comment">// void output(string &amp;key, int value);</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (!input-&gt;done())</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">string</span> s = input-&gt;value().content;</div><div class="line">            <span class="keyword">int</span> st = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> en = <span class="number">0</span>; en &lt;= s.length(); ++en)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span> (en == s.length() || s[en] == <span class="string">' '</span>)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span> (en &gt; st)</div><div class="line">                    &#123;</div><div class="line">                    <span class="built_in">string</span> tmp = s.substr(st,en-st);</div><div class="line">                        output(tmp,<span class="number">1</span>); </div><div class="line">                    &#125;</div><div class="line">                    st = en+<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            input-&gt;next();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">mycomparison</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; &amp;a,<span class="keyword">const</span> pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; &amp;b)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (a.second &lt; b.second)</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        <span class="keyword">if</span> (a.second &gt; b.second)</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> (a.first &gt; b.first);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopKFrequentWordsReducer</span>:</span> <span class="keyword">public</span> Reducer &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> K;</div><div class="line">    priority_queue&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;,<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt;,mycomparison&gt; qu;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUp</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="comment">// initialize your data structure here</span></div><div class="line">        K = k;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reduce</span><span class="params">(<span class="built_in">string</span> &amp;key, Input&lt;<span class="keyword">int</span>&gt;* input)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (!input-&gt;done())</div><div class="line">        &#123;</div><div class="line">            sum += input-&gt;value();</div><div class="line">            input-&gt;next();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        qu.push(make_pair(key,sum));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cleanUp</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// Please directly use func 'output' to output </span></div><div class="line">        <span class="comment">// the top k pairs &lt;word, times&gt; into output buffer.</span></div><div class="line">        <span class="comment">// void output(string &amp;key, int &amp;value);</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K &amp;&amp; !qu.empty(); ++i)</div><div class="line">        &#123;</div><div class="line">            pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; cur = qu.top();</div><div class="line">            output(cur.first,cur.second);</div><div class="line">            qu.pop();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Summary&quot;&gt;&lt;a href=&quot;#Problem-Summary&quot; class=&quot;headerlink&quot; title=&quot;Problem Summary&quot;&gt;&lt;/a&gt;Problem Summary&lt;/h1&gt;&lt;p&gt;Find top k frequent words with map reduce framework.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://suzyz.github.io/categories/Algorithm/"/>
    
    
      <category term="LintCode" scheme="https://suzyz.github.io/tags/LintCode/"/>
    
      <category term="Map Reduce" scheme="https://suzyz.github.io/tags/Map-Reduce/"/>
    
  </entry>
  
  <entry>
    <title>LintCode/Maximum Gap</title>
    <link href="https://suzyz.github.io/2017/11/04/maximum-gap/"/>
    <id>https://suzyz.github.io/2017/11/04/maximum-gap/</id>
    <published>2017-11-04T11:59:56.000Z</published>
    <updated>2017-11-04T12:40:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Summary"><a href="#Problem-Summary" class="headerlink" title="Problem Summary"></a>Problem Summary</h1><p>Given an unsorted array of N integers, find the maximum difference between the successive elements in its sorted form.</p><a id="more"></a><h1 id="Solution-1-O-NlogN-time"><a href="#Solution-1-O-NlogN-time" class="headerlink" title="Solution 1: O(NlogN) time"></a>Solution 1: O(NlogN) time</h1><p>Sort the array with quick sort, merge sort or heap sort. Then iterate through the array.</p><h1 id="Solution-2-O-N-time"><a href="#Solution-2-O-N-time" class="headerlink" title="Solution 2: O(N) time"></a>Solution 2: O(N) time</h1><p>We know that bucket sort only takes O(N) time to allocate the numbers to buckets. If we make sure that the size of each bucket is small enough, we can save us the trouble of gathering the numbers from buckets.</p><p>Actually, once we notice that the lower limit of the answer is L = (max - min)/(N-1), we can set the bucket size to ceil(L) (L rounds up to ceil(l)). Then the maximum difference between numbers in one bucket is at most ceil(L)-1, which is smaller than the answer we want. So we only need to consider the differences of numbers in different buckets. To implement this, we can iterate through each non-empty buckets, and for two adjacent non-empty buckets A and B, we update the answer with the difference between the minimum in B and the maximum in A, i.e. min(B) - max(A).</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * @param nums: an array of integers</div><div class="line">     * @return: the maximun difference</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = nums.size();</div><div class="line">        <span class="keyword">if</span> (n&lt;<span class="number">2</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> minv = nums[<span class="number">0</span>], maxv = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</div><div class="line">        &#123;</div><div class="line">        minv = min(minv,nums[i]);</div><div class="line">        maxv = max(maxv,nums[i]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (minv == maxv)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> len = <span class="built_in">ceil</span>(<span class="number">1.0</span> * (maxv - minv) / (n<span class="number">-1</span>));</div><div class="line">        <span class="keyword">int</span> m = <span class="built_in">ceil</span>(<span class="number">1.0</span> * (maxv - minv) / len) + <span class="number">1</span>;</div><div class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; buckets[m];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">        &#123;</div><div class="line">        <span class="keyword">int</span> cur = (nums[i] - minv)/len;</div><div class="line">        buckets[cur].insert(nums[i]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">bool</span> is_first = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">int</span> last = <span class="number">0</span>, ans = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</div><div class="line">        &#123;</div><div class="line">        <span class="keyword">if</span> (buckets[i].size() == <span class="number">0</span>)</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">if</span> (is_first)</div><div class="line">        is_first = <span class="literal">false</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        ans = max(ans, *buckets[i].begin() - *buckets[last].rbegin());</div><div class="line">        </div><div class="line">        last = i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Summary&quot;&gt;&lt;a href=&quot;#Problem-Summary&quot; class=&quot;headerlink&quot; title=&quot;Problem Summary&quot;&gt;&lt;/a&gt;Problem Summary&lt;/h1&gt;&lt;p&gt;Given an unsorted array of N integers, find the maximum difference between the successive elements in its sorted form.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://suzyz.github.io/categories/Algorithm/"/>
    
    
      <category term="LintCode" scheme="https://suzyz.github.io/tags/LintCode/"/>
    
      <category term="Bucket Sort" scheme="https://suzyz.github.io/tags/Bucket-Sort/"/>
    
      <category term="Sort" scheme="https://suzyz.github.io/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>LintCode/Median of Two Sorted Arrays</title>
    <link href="https://suzyz.github.io/2017/11/04/median-of-two-sorted-arrays/"/>
    <id>https://suzyz.github.io/2017/11/04/median-of-two-sorted-arrays/</id>
    <published>2017-11-04T11:09:47.000Z</published>
    <updated>2017-11-04T11:55:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Summary"><a href="#Problem-Summary" class="headerlink" title="Problem Summary"></a>Problem Summary</h1><p>Given two sorted arrays A and B of size m and n respectively, find the median of the two sorted arrays.</p><a id="more"></a><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>Apparently, we can merge A and B to get a new sorted array C. Then the answer is the median of C.<br>The time and space complexities are both O(M+N), so let us think about better solutions.</p><p>Suppose M+N is odd, then finding the median of C is actually finding the ((M+N+1)/2)th number of C. So we need a way to find the kth number of C in less than linear time, which leads us to think about algorithms with O(log(M+N)) time complexity, such as binary search.</p><p>The point of binary search is to cut the search range by half each time, I think. But can we do the same thing in this problem? To answer this question, let us look at A[k/2-1] and B[k/2-1], which we use M1 and M2 to denote respectively.</p><p>In array A, there are k/2-1 numbers smaller than M1, and m-k/2 numbers greater than it. The situation is similar for B and M2. So, if M1 and M2 are equal, there are exactly k-1 numbers in C smaller or equal to M1. Thus M1 is the kth number of C. If M1 &lt; M2, there are less than k-2 numbers in C smaller than M1; therefore, we know M1 and any number smaller than it are not the target we want. So it is safe for us to throw the first k/2 numbers of A out of consideration. The approach is similar when M1 &gt; M2.</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * @param A: An integer array</div><div class="line">     * @param B: An integer array</div><div class="line">     * @return: a double whose format is *.5 or *.0</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> tot = A.size() + B.size();</div><div class="line">    <span class="keyword">if</span> (tot == <span class="number">0</span>)</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> m = A.size(), n = B.size();</div><div class="line">    <span class="keyword">if</span> (tot%<span class="number">2</span>)</div><div class="line">    <span class="keyword">return</span> find_kth(<span class="number">0</span>,m,A,<span class="number">0</span>,n,B,tot/<span class="number">2</span>+<span class="number">1</span>);</div><div class="line">    <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0.5</span> * (find_kth(<span class="number">0</span>,m,A,<span class="number">0</span>,n,B,tot/<span class="number">2</span>) + find_kth(<span class="number">0</span>,m,A,<span class="number">0</span>,n,B,tot/<span class="number">2</span>+<span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find_kth</span><span class="params">(<span class="keyword">int</span> base1,<span class="keyword">int</span> len1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> base2, <span class="keyword">int</span> len2, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B, <span class="keyword">int</span> k)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (len1 &gt; len2)</div><div class="line">            <span class="keyword">return</span> find_kth(base2,len2,B,base1,len1,A,k);</div><div class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> B[base2 + k<span class="number">-1</span>];</div><div class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> min(A[base1],B[base2]);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> half1 = min(k/<span class="number">2</span>, len1);</div><div class="line">        <span class="keyword">int</span> half2 = k - half1;</div><div class="line">        <span class="keyword">if</span> (A[base1 + half1 - <span class="number">1</span>] == B[base2 + half2 - <span class="number">1</span>])</div><div class="line">            <span class="keyword">return</span> A[base1 + half1 - <span class="number">1</span>];</div><div class="line">        <span class="keyword">else</span></div><div class="line">        <span class="keyword">if</span> (A[base1 + half1 - <span class="number">1</span>] &lt; B[base2 + half2 - <span class="number">1</span>])</div><div class="line">            <span class="keyword">return</span> find_kth(base1 + half1, len1 - half1, A, base2,len2,B, k - half1);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> find_kth(base1,len1,A, base2 + half2, len2 - half2, B, k - half2);</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Summary&quot;&gt;&lt;a href=&quot;#Problem-Summary&quot; class=&quot;headerlink&quot; title=&quot;Problem Summary&quot;&gt;&lt;/a&gt;Problem Summary&lt;/h1&gt;&lt;p&gt;Given two sorted arrays A and B of size m and n respectively, find the median of the two sorted arrays.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://suzyz.github.io/categories/Algorithm/"/>
    
    
      <category term="Array" scheme="https://suzyz.github.io/tags/Array/"/>
    
      <category term="LintCode" scheme="https://suzyz.github.io/tags/LintCode/"/>
    
      <category term="Binary Search" scheme="https://suzyz.github.io/tags/Binary-Search/"/>
    
  </entry>
  
</feed>
